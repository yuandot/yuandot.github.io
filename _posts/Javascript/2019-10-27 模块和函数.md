---
layout: post
title:  "模块和函数"
categories: JavaScript
tag: JavaScript 
---

* content
{:toc}


## 1 关于模块
参考链接:  
[彻底搞清楚javascript中的require、import和export](https://www.cnblogs.com/libin-1/p/7127481.html)  
### 1.1 定义和使用
模块就是实现特定功能的一组方法，只要把不同的函数简单地放在一起，就算一个模块。  
例如：

    // 这种写法的确定，污染全局变量，无法保证不与其他模块发生变量
    // 名冲突，而且模块成员之间看不出直接关系
    // 使用时直接调用 m1()，m2() 就可以
    function m1(){
    　//...
    }
    function m2(){
    　//...　　
    }
    
    // 可以封装在一个对象里面，缺点是会暴露所有模块成员，内部状态可以被外部改写
    // 使用时调用 module1.m1()，module1._count，module1.m2() 就可以
    var module1 = new Object({
    _count : 0,
    　m1 : function (){
    　　//...
    　},
    　m2 : function (){
    　　//...
    　}
    });
    
    // 立即执行函数格式(Immediately-Invoked Function Expression，IIFE)，可以达到不暴露私有成员的目的
    // 使用同上
    var module = (function() {
    var _count = 0;
    var m1 = function() {
    alert(_count)
    }
    var m2 = function() {
    alert(_count + 1)
    }
     
    return {
    m1: m1,
    m2: m2
    }
    })()
    
### 1.2 背景介绍
在 es6 以前，还没有提出一套官方的规范，从社区和框架推广程度而言，目前通行的 javascript 模块规范有两种：**CommonJS** 和 **AMD**。

#### 1.2.1 CommonJS 规范(node.js)  
2009年，美国程序员 Ryan Dahl 创造了 node.js 项目，将 javascript 语言用于服务器端编程。

这标志 ”Javascript 模块化编程” 正式诞生。前端的复杂程度有限，没有模块也是可以的，但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。

node 编程中最重要的思想之一就是模块，而正是这个思想，让 JavaScript 的大规模工程成为可能。模块化编程在 js 界流行，也是基于此，随后在浏览器端，requirejs 和 seajs 之类的工具包也出现了，可以说在对应规范下，require 统治了 ES6 之前的所有模块化编程，即使现在，在 ES6 module 被完全实现之前，还是这样。 

在 CommonJS 中,暴露模块使用 module.exports 和 exports，很多人不明白暴露对象为什么会有两个,后面会介绍区别。  
在 CommonJS 中，有一个全局性方法 require()，用于加载模块。假定有一个数学模块 math.js，就可以像下面这样加载：   

    var math = require('math');
    
然后，就可以调用模块提供的方法：  

    var math = require('math'); 
    math.add(2,3); // 5

正是由于 CommonJS 使用的 require 方式的推动，才有了后面的 AMD、CMD 也采用的 require 方式来引用模块的风格。

#### 1.2.2 AMD 规范(AMD&require.js)

有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。    

但是，由于一个重大的局限，使得 CommonJS 规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题：

    var math = require('math');   
    math.add(2, 3);
    
第二行 math.add(2, 3)，在第一行 require(‘math’) 之后运行，因此必须等 math.js 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。

这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。    

因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。   

AMD 是 ”Asynchronous Module Definition” 的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。   

模块必须采用特定的 define() 函数来定义：

    define(id?, dependencies?, factory)
    
> id：字符串，模块名称(可选)  
> dependencies：是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式  
> factory：工厂方法，返回一个模块函数  


如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。

    // math.js  
    define(function (){ 
                var add = function (x,y){   
                    return x+y;   
                    };
                return {
                    add: add  
                }; 
            }); 
            
如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。

    define(['Lib'], function(Lib){
            function foo(){
            Lib.doSomething();
            }
            return {
                foo : foo
            };
        });
        
当 require() 函数加载上面这个模块的时候，就会先加载 Lib.js 文件。

AMD 也采用 require() 语句加载模块，但是不同于 CommonJS，它要求两个参数：

    require([module], callback);
    
第一个参数 [module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数。如果将前面的代码改写成 AMD 形式，就是下面这样：

    require(['math'], function (math) {
            math.add(2, 3);
        });
        
math.add() 与math 模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD 比较适合浏览器环境。

目前，主要有两个 Javascript 库实现了 AMD 规范：require.js 和 curl.js。

#### 1.2.3 CMD规范

CMD (Common Module Definition), 是 seajs 推崇的规范，CMD 则是依赖就近，用的时候再 require。它写起来是这样的：

    define(function(require, exports, module) {
        var clock = require('clock');
        clock.start();
    });
    
CMD 与 AMD 一样，也是采用特定的 define() 函数来定义,用 require 方式来引用模块

    define(id?, dependencies?, factory)
    
>id：字符串，模块名称(可选)   
>dependencies：是我们要载入的依赖模块(可选)，使用相对路径。注意是数组格式   
>factory：工厂方法，返回一个模块函数  

    define('hello', ['jquery'], function(require, exports, module) {
            // 模块代码
        });
        
如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。

    define(function(require, exports, module) {
        // 模块代码
    });
    
注意：带 id 和 dependencies 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。

#### 1.2.4 CMD与AMD区别

AMD 和 CMD 最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。

AMD 依赖前置，js 可以方便知道依赖模块是谁，立即加载；

而 CMD 就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病 CMD 的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。  

#### 1.2.5 现阶段的标准

ES6 标准发布后，module 成为标准，标准使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的node 模块中，我们依然采用的是 CommonJS 规范，使用 require 引入模块，使用 module.exports 导出接口。

##### 1.2.5.1 export导出模块

export 语法声明用于导出函数、对象、指定文件（或模块）的原始值。

**注意：在 node 中使用的是 exports，不要混淆了**

export 有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。

    export { name1, name2, …, nameN };
    export { variable1 as name1, variable2 as name2, …, nameN };
    export let name1, name2, …, nameN; // also var
    export let name1 = …, name2 = …, …, nameN; // also var, const
     
    export default expression;
    export default function (…) { … } // also class, function*
    export default function name1(…) { … } // also class, function*
    export { name1 as default, … };
     
    export * from …;
    export { name1, name2, …, nameN } from …;
    export { import1 as name1, import2 as name2, …, nameN } from …;
    
> name1… nameN：导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用 import 引用   
> default：设置模块的默认导出。设置后 import 不通过“标识符”而直接引用默认导入   
> *：继承模块并导出继承模块所有的方法和属性   
> as：重命名导出“标识符”   
> from：从已经存在的模块、脚本文件…导出   


##### 1.2.5.2 命名式导出

模块可以通过 export 前缀关键词声明导出对象，导出对象可以是多个。这些导出对象用名称进行区分，称之为命名式导出。

    export { myFunction }; // 导出一个已定义的函数
    export const foo = Math.sqrt(2); // 导出一个常量
    
我们可以使用 * 和 from 关键字来实现模块的继承：

    export * from 'article';
    
模块导出时，可以指定模块的导出成员。导出成员可以认为是类中的公有对象，而非导出成员可以认为是类中的私有对象：

    var name = 'IT笔录';
    var domain = 'http://itbilu.com';
 
    export {name, domain}; // 相当于导出 {name:name,domain:domain}
    
模块导出时，我们可以使用 as 关键字对导出成员进行重命名：

    var name = 'IT笔录';
    var domain = 'http://itbilu.com';
 
    export {name as siteName, domain};
    
注意，下面的语法有严重错误的情况：

    // 错误演示
    export 1; // 绝对不可以
 
    var a = 100;
    export a;
 

export 在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出 1 没有任何意义，也不可能在 import 的时候有一个变量与之对应

export a 虽然看上去成立，但是 a 的值是一个数字，根本无法完成解构，因此必须写成 export {a} 的形式。即使 a 被赋值为一个 function，也是不允许的。而且，大部分风格都建议，模块中最好在末尾用一个 export 导出所有的接口，例如：

    export {fun as default,a,b,c};
    
##### 1.2.5.3 默认导出

默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在import引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块 import 导入时也会很容易引用。

    export default function() {}; // 可以导出一个函数
    export default class(){}; // 也可以出一个类
    
##### 1.2.5.4 命名式导出与默认导出

默认导出可以理解为另一种形式的命名导出，默认导出可以认为是使用了 default 名称的命名导出。

下面两种导出方式是等价的：

    const D = 123;
 
    export default D;
    export { D as default };
    
##### 1.2.5.5 export使用示例

使用名称导出一个模块时：

    // "my-module.js" 模块
    export function cube(x) {
        return x * x * x;
    }
    const foo = Math.PI + Math.SQRT2;
    export { foo };
    
在另一个模块（脚本文件）中，我们可以像下面这样引用：

    import { cube, foo } from 'my-module';
    console.log(cube(3)); // 27
    console.log(foo); // 4.555806215962888
    
使用默认导出一个模块时：

    // "my-module.js"模块
    export default function (x) {
        return x * x * x;
    }
    
在另一个模块（脚本文件）中，我们可以像下面这样引用，相对名称导出来说使用更为简单：

    // 引用 "my-module.js"模块
    import cube from 'my-module';
    console.log(cube(3)); // 27
    
##### 1.2.5.6 import引入模块

import 语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。

import 模块导入与 export 模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。

import 的语法跟 require 不同，而且 import 必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。

    import defaultMember from "module-name";
    import * as name from "module-name";
    import { member } from "module-name";
    import { member as alias } from "module-name";
    import { member1 , member2 } from "module-name";
    import { member1 , member2 as alias2 , [...] } from "module-name";
    import defaultMember, { member [ , [...] ] } from "module-name";
    import defaultMember, * as name from "module-name";
    import "module-name";
    
> name：从将要导入模块中收到的导出值的名称  
> member, memberN：从导出模块，导入指定名称的多个成员  
> defaultMember：从导出模块，导入默认导出成员  
> alias, aliasN：别名，对指定导入成员进行的重命名  
> module-name：要导入的模块。是一个文件名  
> as：重命名导入成员名称（“标识符”）  
> from：从已经存在的模块、脚本文件等导入  

##### 1.2.5.7 命名式导入

我们可以通过指定名称，就是将这些成员插入到当作用域中。导出时，可以导入单个成员或多个成员：

注意，花括号里面的变量与 export 后面的变量一一对应

    import {myMember} from "my-module";
    import {foo, bar} from "my-module";
    
通过 * 符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（’my-module.js’）所有的导出绑定内容，插入到当前模块（’myModule’）的作用域中：

    import * as myModule from "my-module";
    
导入模块对象时，也可以使用 as 对导入成员重命名，以方便在当前模块内使用：

    import {reallyReallyLongModuleMemberName as shortName} from "my-module";
    
导入多个成员时，同样可以使用别名：

    import {reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short} from "my-module";
    
导入一个模块，但不进行任何绑定：

    import "my-module";
    
##### 1.2.5.8 默认导入

在模块导出时，可能会存在默认导出。同样的，在导入时可以使用 import 指令导出这些默认值。

直接导入默认值：

    import myDefault from "my-module";
    
也可以在命名空间导入和名称导入中，同时使用默认导入：

    import myDefault, * as myModule from "my-module"; // myModule 做为命名空间使用
    import myDefault, {foo, bar} from "my-module"; // 指定成员导入

##### 1.2.5.9 import使用示例

    // --file.js--
    function getJSON(url, callback) {
        let xhr = new XMLHttpRequest();
        xhr.onload = function () {
            callback(this.responseText)
        };
        xhr.open("GET", url, true);
        xhr.send();
    }
    
    export function getUsefulContents(url, callback) {
        getJSON(url, data => callback(JSON.parse(data)));
    }
    
    // --main.js--
    import { getUsefulContents } from "file";
        getUsefulContents("http://itbilu.com", data => {
        doSomethingUseful(data);
    });
    
##### 1.2.5.10 default关键字

    // d.js
    export default function() {}
 
    // 等效于：
    function a() {};
    export {a as default};
    
在import的时候，可以这样用：

    import a from './d';
 
    // 等效于，或者说就是下面这种写法的简写，是同一个意思
    
    import {default as a} from './d';
    
这个语法糖的好处就是 import 的时候，可以省去花括号 {}。

简单的说，如果 import 的时候，你发现某个变量没有花括号括起来（没有 * 号），那么你在脑海中应该把它还原成有花括号的 as 语法。

所以，下面这种写法你也应该理解了吧：

    import $,{each,map} from 'jquery';
import 后面第一个 $ 是 {defalut as $} 的替代写法。

##### 1.2.5.11 as关键字

as 简单的说就是取一个别名, export 中可以用，import 中其实可以用：

    // a.js
    var a = function() {};
    export {a as fun};
     
    // b.js
    import {fun as a} from './a';
    a();
    
上面这段代码，export 的时候，对外提供的接口是 fun，它是 a.js 内部 a 这个函数的别名，但是在模块外面，认不到 a，只能认到 fun。

import 中的 as 就很简单，就是你在使用模块里面的方法的时候，给这个方法取一个别名，好在当前的文件里面使用。之所以是这样，是因为有的时候不同的两个模块可能通过相同的接口，比如有一个 c.js 也通过了 fun 这个接口：

    // c.js
    export function fun() {};
    
如果在 b.js 中同时使用 a 和 c 这两个模块，就必须想办法解决接口重名的问题，as 就解决了。

##### 1.2.5.12 CommonJS 中 module.exports 与 exports 的区别

* Module.exports   
The module.exports object is created by the Module system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to module.exports. Note that assigning the desired object to exports will simply rebind the local exports variable, which is probably not what you want to do.   
译文：module.exports 对象是由模块系统创建的。 有时这是难以接受的；许多人希望他们的模块成为某个类的实例。 为了实现这个，需要将期望导出的对象赋值给 module.exports。 注意，将期望的对象赋值给 exports 会简单地重新绑定到本地 exports 变量上，这可能不是你想要的。

* exports   
The exports variable is available within a module’s file-level scope, and is assigned the value of module.exports before the module is evaluated. It allows a shortcut, so that module.exports.f = … can be written more succinctly as exports.f = …. However, be aware that like any variable, if a new value is assigned to exports, it is no longer bound to module.exports:   
译文：exports 变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于 module.exports 的值。它有一个快捷方式，以便 module.exports.f = … 可以被更简洁地写成 exports.f = …。 注意，就像任何变量，如果一个新的值被赋值给 exports，它就不再绑定到 module.exports(其实是 exports. 属性会自动挂载到没有命名冲突的module.exports.属性)

从 Api 文档上面的可以看出，从 require 导入方式去理解，关键有两个变量(全局变量 module.exports，局部变量 exports)、一个返回值 (module.exports)

    function require(...) {
        var module = { exports: {} };
        ((module, exports) => {
            // 你的被引入代码 Start
            // var exports = module.exports = {}; (默认都有的)
            function some_func() {};
            exports = some_func;
            // 此时，exports不再挂载到module.exports，
            // export将导出{}默认对象
            module.exports = some_func;
            // 此时，这个模块将导出some_func对象，覆盖exports上的some_func
            // 你的被引入代码 End
        })(module, module.exports);
        // 不管是exports还是module.exports，最后返回的还是module.exports
        return module.exports;
    }
    demo.js:

    console.log(exports); // {}
    console.log(module.exports); // {}
    console.log(exports === module.exports); // true
    console.log(exports == module.exports); // true
    console.log(module);
    /**
    Module {
    id: '.',
    exports: {},
    parent: null,
    filename: '/Users/larben/Desktop/demo.js',
    loaded: false,
    children: [],
    paths:
    [ '/Users/larben/Desktop/node_modules',
    '/Users/larben/node_modules',
    '/Users/node_modules',
    '/node_modules' ] }
    */
    
**注意:**  
**每个js文件一创建，都有一个var exports = module.exports = {},使exports和module.exports都指向一个空对象。**    
**module.exports 和 exports 所指向的内存地址相同**

## 2 关于函数

参考链接：
[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions)

函数可以通过外部代码调用的一个子程序（递归时可由内部函数调用），值传递给一个函数，函数将返回一个值。

在 JavaScript 中，函数是头等 (first-class) 对象，因为它们可以像任何其他对象一样具有属性和方法。它们与其他对象的区别在于函数可以被调用。简而言之，它们是 Function 对象。

如果一个函数中没有使用 return 语句，则它默认返回 undefined。要想返回一个特定的值，则函数必须使用 return 语句来指定一个要返回的值。(使用 new 关键字调用一个构造函数除外)。

调用函数时，传递给函数的值被称为函数的实参（值传递），对应位置的函数参数名叫作形参。如果实参是一个包含原始值(数字，字符串，布尔值)的变量，则就算函数在内部改变了对应形参的值，返回后，该实参变量的值也不会改变。如果实参是一个对象引用，则对应形参会和该实参指向同一个对象。假如函数在内部改变了对应形参的值，返回后，实参指向的对象的值也会改变。

在函数执行时，this 关键字并不会指向正在运行的函数本身，而是指向调用该函数的对象。所以，如果你想在函数内部获取函数自身的引用，只能使用函数名或者使用 arguments.callee 属性(严格模式下不可用)，如果该函数是一个匿名函数,则你只能使用后者。  

### 2.1 函数定义
#### 2.1.1 函数声明(函数语句)

    function name([param[, param[, ... param]]]) { statements }
  
> name：函数名   
> param：传递给函数的参数的名称，一个函数最多可以有 255 个参数。  
> statements：组成函数体的声明语句。  

一个被函数声明创建的函数是一个 Function 对象，具有 Function 对象的所有属性、方法和行为。

函数可以被有条件来声明，这意味着，在一个 if 语句里，函数声明是可以嵌套的。有的浏览器会将这种有条件的声明看成是无条件的声明，无论这里的条件是 true 还是 false，浏览器都会创建函数。因此，它们不应该被使用。

JavaScript 中的函数声明被提升到了函数定义，但是函数表达式function expressions 不会被提升。你可以在函数声明之前使用该函数:

    hoisted(); // "foo"

    function hoisted() {
         console.log("foo"); 
    }
    
    
    /* equal to*/
    var hoisted; 
    
    hoisted = function() {
      console.log("foo");
    }
    hoisted();
    // "foo" 

函数可以被有条件来声明，这意味着，函数声明可能出现在一个 if 语句里，但是，这种声明方式在不同的浏览器里可能有不同的效果。因此，不应该在生成环境代码中使用这种声明方式，应该使用函数表达式来代替。例如：

    var hoisted = "foo" in this;
    console.log(`'foo' name ${hoisted ? "is" : "is not"} hoisted. typeof foo is ${typeof foo}`);
    //  if(false) 改为 if(true)，结果也是一样的
    if (false) {
      function foo(){ return 1; }
    }
    
    // 在Chrome里: 
    // 'foo' 变量名被提升，但是 typeof foo 为 undefined
    // 
    // 在Firefox里:
    // 'foo' 变量名被提升. 但是 typeof foo 为 undefined
    //
    // 在Edge里:
    // 'foo' 变量名未被提升. 而且 typeof foo 为 undefined
    // 
    // 在Safari里:
    // 'foo' 变量名被提升. 而且 typeof foo 为 function


#### 2.1.2 函数表达式 (function expression)

函数表达式和函数声明非常相似，它们甚至有相同的语法（查看函数表达式了解详情）。一个函数表达式可能是一个更大的表达式的一部分。函数表达式与函数声明的最主要区别是可以定义函数“名字”（例如可以在调用堆栈时使用）或者使用“匿名”函数。函数表达式不会提升，所以不能在定义之前调用。

    var myFunction = function name([param[, param[, ... param]]]) { statements }

> name：函数名，可以省略。当省略函数名的时候，该函数就成为了匿名函数。  
>param：传递给函数的参数的名称，一个函数最多可以有255个参数.  
>statements：组成函数体的声明语句。  


下面是匿名函数的一个例子（函数没有名字）：

    var myFunction = function() {
        // statements
    }
    
也可以在定义时为函数命名：

    var myFunction = function namedFunction(){
        // statements
    }
    
命名函数表达式的好处是当我们遇到错误时，堆栈跟踪会显示函数名，容易寻找错误。

可以看到，上面的两个例子都不以 function 开头。不以 function 开头的函数语句就是函数表达式定义。

当函数只使用一次时，通常使用 IIFE (Immediately Invokable Function Expressions)。

    (function() {
        statements
    })();
    
IIFE 是在函数声明后立即调用的函数表达式。

如果你想在函数体内部引用当前函数，则需要创建一个命名函数表达式。然后函数名称将会（且只会）作为函数体（作用域内）的本地变量。这样也可以避免使用非标准的 arguments.callee 属性。例如：

    var math = {
      'factorial': function factorial(n) {
        if (n <= 1)
          return 1;
        return n * factorial(n - 1);
      }
    };

被函数表达式赋值的那个变量会有一个name属性，如果你把这个变量赋值给另一个变量的话，这个name属性的值也不会改变。如果函数是一个匿名函数，那name属性的值就是被赋值的变量的名称（隐藏值）。如果函数不是匿名的话，那name属性的值就是这个函数的名称（显性值）。这对于箭头函数也同样适用（箭头函数没有名字，所以你只能赋予name属性一个隐性名）。例如：

    var foo = function() {}
    foo.name // "foo"
    
    var foo2 = foo
    foo2.name // "foo"
    
    var bar = function baz() {}
    bar.name // "baz"
    
    console.log(foo === foo2); //true
    console.log(typeof baz);// undefined 
    console.log(bar === baz); // false (errors because baz == undefined)
    
#### 2.1.3 函数生成器声明 (function* 语句)

函数声明有一种特殊的语法：

    function* name([param[, param[, ...param]]]) { statements }
    
> name：函数名   
> param：传递给函数的参数的名称，一个函数最多可以有 255 个参数。  
> statements：组成函数体的声明语句。  

function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个  Generator  对象。例如：

    function* generator(i) {
      yield i;
      yield i + 10;
    }
    
    var gen = generator(10);
    
    console.log(gen.next().value);
    // expected output: 10
    
    console.log(gen.next().value);
    // expected output: 20


#### 2.1.4 函数生成器表达式 (function*表达式)

构造函数表达式和函数声明类似，并且有着相同的语法：

    function* [name]([param] [, param] [..., param]) { statements }
    
> name：函数名，可以省略。当省略函数名的时候，该函数就成为了匿名函数。  
>param：传递给函数的参数的名称，一个函数最多可以有255个参数.  
>statements：组成函数体的声明语句。 

function * 表达式和function * 声明比较相似，并具有几乎相同的语法。function* 表达式和function * 声明之间主要区别就是函数名，即在创建匿名函数时，function* 表达式可以省略函数名。
function*关键字可以在表达式内部定义一个生成器函数。例如：

    function* foo() {
      yield 'a';
      yield 'b';
      yield 'c';
    }
    
    var str = "";
    for (let val of foo()) {
      str = str + val;
    }
    
    console.log(str);
    // expected output: "abc"

#### 2.1.5 箭头函数表达式 (=>)

箭头函数表达式有着更短的语法，并在词汇方面结合这个值  (详情请查阅 arrow functions ):

    ([param] [, param]) => { statements } 
    param => expression
    
    (参数1, 参数2, …, 参数N) => { 函数声明 }

    //相当于：(参数1, 参数2, …, 参数N) =>{ return 表达式; }
    (参数1, 参数2, …, 参数N) => 表达式（单一）
    
    // 当只有一个参数时，圆括号是可选的：
    (单一参数) => {函数声明}
    单一参数 => {函数声明}
    
    // 没有参数的函数应该写成一对圆括号。
    () => {函数声明}
    
    //加括号的函数体返回对象字面表达式：
    参数=> ({foo: bar})
    
    //支持剩余参数和默认参数
    (参数1, 参数2, ...rest) => {函数声明}
    (参数1 = 默认值1,参数2, …, 参数N = 默认值N) => {函数声明}
    
    //同样支持参数列表解构
    let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
    f();  // 6

> param：参数名称. 零参数需要用()表示.  只有一个参数时不需要括号. (例如 foo => 1)
> statements or expression：多个声明statements需要用大括号括起来，而单个表达式时则不需要。表达式expression也是该函数的隐式返回值。

箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。

引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。

更短的函数：

    var elements = [
      'Hydrogen',
      'Helium',
      'Lithium',
      'Beryllium'
    ];
    
    elements.map(function(element) { 
      return element.length; 
    }); // 返回数组：[8, 6, 7, 9]
    
    // 上面的普通函数可以改写成如下的箭头函数
    elements.map((element) => {
      return element.length;
    }); // [8, 6, 7, 9]
    
    // 当箭头函数只有一个参数时，可以省略参数的圆括号
    elements.map(element => {
     return element.length;
    }); // [8, 6, 7, 9]
    
    // 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号
    elements.map(element => element.length); // [8, 6, 7, 9]
    
    // 在这个例子中，因为我们只需要 `length` 属性，所以可以使用参数解构
    // 需要注意的是字符串 `"length"` 是我们想要获得的属性的名称，而 `lengthFooBArX` 则只是个变量名，
    // 可以替换成任意合法的变量名
    elements.map(({ "length": lengthFooBArX }) => lengthFooBArX); // [8, 6, 7, 9]

不绑定 this:  
在箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被作为“对象方法”调用则为基础对象等）。This被证明是令人厌烦的面向对象风格的编程。例如：

    function Person() {
      // Person() 构造函数定义 `this`作为它自己的实例.
      this.age = 0;
    
      setInterval(function growUp() {
        // 在非严格模式, growUp()函数定义 `this`作为全局对象, 
        // 与在 Person()构造函数中定义的 `this`并不相同.
        this.age++;
      }, 1000);
    }
    
    var p = new Person();
    
在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。

    function Person() {
      var that = this;
      that.age = 0;
    
      setInterval(function growUp() {
        //  回调引用的是`that`变量, 其值是预期的对象. 
        that.age++;
      }, 1000);
    }
   
或者，可以创建绑定函数，以便将预先分配的this值传递到绑定的目标函数（上述示例中的growUp()函数）。

箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同：

    function Person(){
      this.age = 0;
    
      setInterval(() => {
        this.age++; // |this| 正确地指向 p 实例
      }, 1000);
    }
    
    var p = new Person();

鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。例如：

    function Person() {
      this.age = 0;
      var closure = "123"
      setInterval(function growUp() {
        this.age++;
        console.log(closure)
      }, 1000);
    }
    
    var p = new Person();
    
    function PersonX() {
      'use strict'
      this.age = 0;
      var closure = "123"
      setInterval(()=>{
        this.age++;
        console.log(closure)
      }, 1000);
    }
    
    var px = new PersonX();
    
由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this---译者注），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立---译者注）例如：

    var adder = {
      base : 1,
        
      add : function(a) {
        var f = v => v + this.base;
        return f(a);
      },
    
      addThruCall: function(a) {
        var f = v => v + this.base;
        var b = {
          base : 2
        };
                
        return f.call(b, a);
      }
    };
    
    console.log(adder.add(1));         // 输出 2
    console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注）
    
箭头函数不绑定Arguments 对象。因此，在本示例中，arguments只是引用了封闭作用域内的arguments：
    
    var arguments = [1, 2, 3];
    var arr = () => arguments[0];
    
    arr(); // 1
    
    function foo(n) {
      var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象，arguments[0] 是 n,即传给foo函数的第一个参数
      return f();
    }
    
    foo(1); // 2
    foo(2); // 4
    foo(3); // 6
    foo(3,2);//6 
    
在大多数情况下，使用剩余参数是相较使用arguments对象的更好选择。例如：

    function foo(arg) { 
      var f = (...args) => args[0]; 
      return f(arg); 
    }
    foo(1); // 1
    
    function foo(arg1,arg2) { 
        var f = (...args) => args[1]; 
        return f(arg1,arg2); 
    } 
    foo(1,2);  //2
    
箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。例如：

    'use strict';
    var obj = {
      i: 10,
      b: () => console.log(this.i, this),
      c: function() {
        console.log( this.i, this)
      }
    }
    obj.b(); 
    // undefined, Window{...}
    obj.c(); 
    // 10, Object {...}
    
箭头函数没有定义this绑定。另一个涉及Object.defineProperty()的示例：

    'use strict';
    var obj = {
      a: 10
    };
    
    Object.defineProperty(obj, "b", {
      get: () => {
        console.log(this.a, typeof this.a, this);
        return this.a+10; 
       // 代表全局对象 'Window', 因此 'this.a' 返回 'undefined'
      }
    });
    
    obj.b; // undefined   "undefined"   Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}  

箭头函数不能用作构造器，和 new一起用会抛出错误。例如：

    var Foo = () => {};
    var foo = new Foo(); // TypeError: Foo is not a constructor

箭头函数没有prototype属性。例如：

    var Foo = () => {};
    console.log(Foo.prototype); // undefined

yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。

记住用params => {object:literal}这种简单的语法返回对象字面量是行不通的。例如：
 
    var func = () => { foo: 1 };               
    // Calling func() returns undefined!
    
    var func = () => { foo: function() {} };   
    // SyntaxError: function statement requires a name
    
这是因为花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。

所以，记得用圆括号把对象字面量包起来：

    var func = () => ({foo: 1});
    
箭头函数在参数和箭头之间不能换行。

    var func = ()
               => 1; 
    // SyntaxError: expected expression, got '=>'
    

虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。

    let callback;
    
    callback = callback || function() {}; // ok
    
    callback = callback || () => {};      
    // SyntaxError: invalid arrow-function arguments
    
    callback = callback || (() => {});    // ok
    
更多示例

    // 空的箭头函数返回 undefined
    let empty = () => {};
    
    (() => 'foobar')(); 
    // Returns "foobar"
    // (这是一个立即执行函数表达式,可参阅 'IIFE'术语表) 
    
    
    var simple = a => a > 15 ? 15 : a; 
    simple(16); // 15
    simple(10); // 10
    
    let max = (a, b) => a > b ? a : b;
    
    // Easy array filtering, mapping, ...
    
    var arr = [5, 6, 13, 0, 1, 18, 23];
    
    var sum = arr.reduce((a, b) => a + b);  
    // 66
    
    var even = arr.filter(v => v % 2 == 0); 
    // [6, 0, 18]
    
    var double = arr.map(v => v * 2);       
    // [10, 12, 26, 0, 2, 36, 46]
    
    // 更简明的promise链
    promise.then(a => {
      // ...
    }).then(b => {
      // ...
    });
    
    // 无参数箭头函数在视觉上容易分析
    setTimeout( () => {
      console.log('I happen sooner');
      setTimeout( () => {
        // deeper code
        console.log('I happen later');
      }, 1);
    }, 1);
    
箭头函数也可以使用条件（三元）运算符：

    var simple = a => a > 15 ? 15 : a;
    simple(16); // 15
    simple(10); // 10

    let max = (a, b) => a > b ? a : b;
    
箭头函数内定义的变量及其作用域

    // 常规写法
    var greeting = () => {let now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
    greeting();          //"Good day."
    console.log(now);    // ReferenceError: now is not defined 标准的let作用域
    
    // 参数括号内定义的变量是局部变量（默认参数）
    var greeting = (now=new Date()) => "Good" + (now.getHours() > 17 ? " evening." : " day.");
    greeting();          //"Good day."
    console.log(now);    // ReferenceError: now is not defined
    
    // 对比：函数体内{}不使用var定义的变量是全局变量
    var greeting = () => {now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
    greeting();           //"Good day."
    console.log(now);     // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)
    
    // 对比：函数体内{} 用var定义的变量是局部变量
    var greeting = () => {var now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
    greeting(); //"Good day."
    console.log(now);    // ReferenceError: now is not defined
    
箭头函数也可以使用闭包：

    // 标准的闭包函数
    function A(){
          var i=0;
          return function b(){
                  return (++i);
          };
    };
    
    var v=A();
    v();    //1
    v();    //2
    
    
    //箭头函数体的闭包（ i=0 是默认参数）
    var Add = (i=0) => {return (() => (++i) )};
    var v = Add();
    v();           //1
    v();           //2
    
    //因为仅有一个返回，return 及括号（）也可以省略
    var Add = (i=0)=> ()=> (++i);

箭头函数递归

    var fact = (x) => ( x==0 ?  1 : x*fact(x-1) );
    fact(5);       // 120
    
#### 2.1.6 Function 构造函数

注意: 不推荐使用 Function 构造函数创建函数,因为它需要的函数体作为字符串可能会阻止一些 JS 引擎优化,也会引起其他问题。

所有其他对象, Function 对象可以用 new 操作符创建:

    new Function (arg1, arg2, ... argN, functionBody)

> arg1, arg2, ... argN：函数使用零个或多个名称作为正式的参数名称。每一个必须是一个符合有效的JavaScript标识符规则的字符串或用逗号分隔的字符串列表,例如“x”,“theValue”或“a,b”。    
> functionBody：一个构成的函数定义的，包含 JavaScript 声明语句的字符串。

使用 Function 构造器生成的 Function 对象是在函数创建时解析的。这比你使用函数声明或者函数表达式并在你的代码中调用更为低效，因为使用后者创建的函数是跟其他代码一起解析的。

所有被传递到构造函数中的参数，都将被视为将被创建的函数的参数，并且是相同的标示符名称和传递顺序。

把 Function 的构造函数当作函数一样调用(不使用 new 操作符)的效果与作为 Function 的构造函数调用一样。

Function 构造函数创建一个新的 Function 对象。直接调用此构造函数可用动态创建函数，但会遭遇来自 eval 的安全问题和相对较小的性能问题。然而，与 eval 不同的是，Function 构造函数只在全局作用域中运行。例如：

    var sum = new Function('a', 'b', 'return a + b');

    console.log(sum(2, 6));
    // expected output: 8
    
每个 JavaScript 函数实际上都是一个 Function 对象。运行 (function(){}).constructor === Function 便可以得到这个结论。

全局的 Function 对象没有自己的属性和方法，但是，因为它本身也是一个函数，所以它也会通过原型链从自己的原型链 Function.prototype 上继承一些属性和方法。

    Function.arguments 
    以数组形式获取传入函数的所有参数。此属性已被arguments替代。
    Function.arity 
    用于指定的函数的参数的个数，但已被删除。使用length属性代替。
    Function.caller 
    获取调用函数的具体对象。
    Function.length
    获取函数的接收参数个数。
    Function.name 
    获取函数的名称。
    Function.displayName 
    获取函数的display name。
    Function.prototype.constructor
    声明函数的原型构造方法，详细请参考 Object.constructor 。
    方法
    Function.prototype.apply()
    在一个对象的上下文中应用另一个对象的方法；参数能够以数组形式传入。
    Function.prototype.bind()
    bind()方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this,传入 bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数.
    Function.prototype.call()
    在一个对象的上下文中应用另一个对象的方法；参数能够以列表形式传入。
    Function.prototype.isGenerator() 
    若函数对象为generator，返回true，反之返回 false。
    Function.prototype.toSource() 
    获取函数的实现源码的字符串。 覆盖了 Object.prototype.toSource 方法。
    Function.prototype.toString()
    获取函数的实现源码的字符串。覆盖了 Object.prototype.toString 方法。

#### 2.1.7 生成器函数的构造函数

注意: GeneratorFunction 不是一个全局对象，但可以从构造函数实例取得。(详情请查阅生成器函数).

注意: 不推荐使用构造器函数的构造函数 (GeneratorFunction constructor)创建函数，因为它需要的函数体作为字符串可能会阻止一些JS引擎优化，也会引起其他问题。

所有其他对象, GeneratorFunction 对象可以用 new 操作符创建：

    new GeneratorFunction (arg1, arg2, ... argN, functionBody)
    
> arg1, arg2, ... argN：函数使用零个或多个名称作为正式的参数名称。每一个必须是一个符合有效的JavaScript标识符规则的字符串或用逗号分隔的字符串列表,例如“x”,“theValue”或“a,b”。  
> functionBody：一个构成的函数定义的，包含JavaScript声明语句的字符串。

GeneratorFunction构造器生成新的生成器函数 对象。在JavaScript中，生成器函数实际上都是GeneratorFunction的实例对象。

注意，GeneratorFunction并不是一个全局对象。它可以通过下面的代码获取。

    Object.getPrototypeOf(function*(){}).constructor
    
当创建函数时，将使用GeneratorFunction构造函数创建的生成器函数对象进行解析。这比使用function* 表达式 声明生成器函数效率更低，并且在代码中调用它，因为这些函数与其余的代码一起被解析。

传递给函数的所有参数按照它们被传递的顺序被视为要创建的函数中参数的标识符的名称。

提示：使用GeneratorFunction构造函数创建的生成器函数不会为其创建上下文创建闭包；它们始终在全局范围内创建。当运行它们时，它们只能访问自己的本地变量和全局变量，而不是从GeneratorFunction构造函数调用的范围的变量。这与使用eval与生成函数表达式的代码不同。

把Function的构造函数当作函数一样调用(不使用new操作符)的效果与作为Function的构造函数调用一样。

    GeneratorFunction.length
    GeneratorFunction构造函数的 length 属性值为 1。
    GeneratorFunction.prototype
    允许向所有生成器函数对象添加属性。


    GeneratorFunction.constructor
    初始值是 GeneratorFunction.
    GeneratorFunction.prototype.prototype
    值是 %GeneratorPrototype%.
    
GeneratorFunction实例从GeneratorFunction.prototype继承方法和属性。与所有构造函数一样，你可以更改构造函数的原型对象以对所有GeneratorFunction实例进行更改。
从GeneratorFunction构造函数创建一个生成器函数

    var GeneratorFunction = Object.getPrototypeOf(function*(){}).constructor
    var g = new GeneratorFunction("a", "yield a * 2");
    var iterator = g(10);
    console.log(iterator.next().value); // 20
    
#### 2.1.8 函数参数

##### 2.1.8.1 默认参数

参考链接： 
[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters)

函数默认参数允许在没有值或undefined被传入时使用默认形参。例如：

    function multiply(a, b = 1) {
        return a * b;
    }
    
    console.log(multiply(5, 2));
    // expected output: 10
    
    console.log(multiply(5));
    // expected output: 5
    
JavaScript 中函数的参数默认是undefined。然而，在某些情况下可能需要设置一个不同的默认值。这是默认参数可以帮助的地方。

以前，一般设置默认参数的方法是在函数体测试参数是否为undefined，如果是的话就设置为默认的值。

下面的例子中，如果在调用multiply时，参数b的值没有提供，那么它的值就为undefined。如果直接执行a * b，函数会返回 NaN。

    function multiply(a, b) {
      return a * b;
    }
    
    multiply(5, 2); // 10
    multiply(5);    // NaN !
    
为了防止这种情况，第二行代码解决了这个问题，其中如果只使用一个参数调用multiply，则b设置为1：

    function multiply(a, b) {
      b = (typeof b !== 'undefined') ?  b : 1;
      return a * b;
    }
    
    multiply(5, 2); // 10
    multiply(5);    // 5
    
有了默认参数，我们不需要再在函数体内做不必要的检查。现在你可以在函数头将b的默认值置为1，例如：   

    function multiply(a, b = 1) {
      return a * b;
    }
    
    multiply(5, 2); // 10
    multiply(5);    // 5

在第二次调用中，即使第一个参数在调用时显式设置为undefined（虽然不是null或其他falsy值），但是num参数的值是默认值，例如：

    function test(num = 1) {
      console.log(typeof num);
    }
    
    test();          // 'number' (num is set to 1)
    test(undefined); // 'number' (num is set to 1 too)
    
    // test with other falsy values:
    test('');        // 'string' (num is set to '')
    test(null);      // 'object' (num is set to null)
    
在函数被调用时，参数默认值会被解析，所以不像Python中的例子，每次函数调用时都会创建一个新的参数对象。例如：
    
    function append(value, array = []) {
      array.push(value);
      return array;
    }
    
    append(1); //[1]
    append(2); //[2], not [1, 2]


这个规则对于函数和变量也是适用的。

    function callSomething(thing = something()) {
     return thing;
    }
    
    let numberOfTimesCalled = 0;
    function something() {
      numberOfTimesCalled += 1;
      return numberOfTimesCalled;
    }
    
    callSomething(); // 1
    callSomething(); // 2
    
已经遇到的参数可用于以后的默认参数：

    function greet(name, greeting, message = greeting + ' ' + name) {
        return [name, greeting, message];
    }
    
    greet('David', 'Hi');  // ["David", "Hi", "Hi David"]
    greet('David', 'Hi', 'Happy Birthday!');  // ["David", "Hi", "Happy Birthday!"]
    
以下这个例子近似模拟了一些比较简单的情况，并说明了特殊情况是怎么被处理的。

    function go() {
      return ':P';
    }
    
    function withDefaults(a, b = 5, c = b, d = go(), e = this, 
                          f = arguments, g = this.value) {
      return [a, b, c, d, e, f, g];
    }
    
    function withoutDefaults(a, b, c, d, e, f, g) {
      switch (arguments.length) {
        case 0:
          a;
        case 1:
          b = 5;
        case 2:
          c = b;
        case 3:
          d = go();
        case 4:
          e = this;
        case 5:
          f = arguments;
        case 6:
          g = this.value;
        default:
      }
      return [a, b, c, d, e, f, g];
    }
    
    withDefaults.call({value: '=^_^='});
    // [undefined, 5, 5, ":P", {value:"=^_^="}, arguments, "=^_^="]
    
    
    withoutDefaults.call({value: '=^_^='});
    // [undefined, 5, 5, ":P", {value:"=^_^="}, arguments, "=^_^="]
    
在 Gecko 33 (Firefox 33 / Thunderbird 33 / SeaMonkey 2.30) 中引入。在函数体内的函数声明不能引用内部的默认参数，并且会在 SpiderMonkey 抛出一个ReferenceError（现在是 TypeError），参见 bug 1022967。默认参数总是会被首先执行，而在函数体内部的函数声明会在之后生效。例如：
    
    // Doesn't work! Throws ReferenceError.
    function f(a = go()) {
      function go() { return ':P'; }
    }
    
在Gecko 26 (Firefox 26 / Thunderbird 26 / SeaMonkey 2.23 / Firefox OS 1.2)之前，以下代码会造成SyntaxError错误。这已经在bug 1022967中修复，并在以后的版本中按预期方式工作。参数仍然设置为从左到右，覆盖默认参数，即使后面的参数没有默认值。

    function f(x = 1, y) { 
      return [x, y]; 
    }
    
    f(); // [1, undefined]
    f(2); // [2, undefined]
    
你可以通过解构赋值为参数赋值：

    function f([x, y] = [1, 2], {z: z} = {z: 3}) { 
      return x + y + z; 
    }
    
    f(); // 6
    
##### 2.1.8.2 剩余参数

参考链接： 
[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)

剩余参数语法允许将数量不限的参数描述成一个数组。例如：

    function sum(...theArgs) {
      return theArgs.reduce((previous, current) => {
        return previous + current;
      });
    }
    
    console.log(sum(1, 2, 3));
    // expected output: 6
    
    console.log(sum(1, 2, 3, 4));
    // expected output: 10
    
    
    
如果函数的最后一个命名参数以...为前缀，则它将成为一个由剩余参数组成的真数组，其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。

    function(a, b, ...theArgs) {
      // ...
    }
    
在上面的例子中，theArgs将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数。

剩余参数和 arguments对象之间的区别主要有三个：

* 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
* arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。
* arguments对象还有一些附加的属性 （如callee属性）。

引入了剩余参数来减少由参数引起的样板代码：

    // Before rest parameters, "arguments" could be converted to a normal array using:
    
    function f(a, b) {
    
      var normalArray = Array.prototype.slice.call(arguments);
      // -- or --
      var normalArray = [].slice.call(arguments);
      // -- or --
      var normalArray = Array.from(arguments);
    
      var first = normalArray.shift(); // OK, gives the first argument
      var first = arguments.shift(); // ERROR (arguments is not a normal array)
    
    }
    
    // Now we can easily gain access to a normal array using a rest parameter
    
    function f(...args) {
      var normalArray = args;
      var first = normalArray.shift(); // OK, gives the first argument
    }
    
剩余参数可以被解构，这意味着他们的数据可以被解包到不同的变量中：

    function f(...[a, b, c]) {
      return a + b + c;
    }
    
    f(1)          // NaN (b and c are undefined)
    f(1, 2, 3)    // 6
    f(1, 2, 3, 4) // 6 (the fourth parameter is not destructured)
    
因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：

    function fun1(...theArgs) {
      alert(theArgs.length);
    }
     
    fun1();  // 弹出 "0", 因为theArgs没有元素
    fun1(5); // 弹出 "1", 因为theArgs只有一个元素
    fun1(5, 6, 7); // 弹出 "3", 因为theArgs有三个元素
    
下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：

    function multiply(multiplier, ...theArgs) {
      return theArgs.map(function (element) {
        return multiplier * element;
      });
    }

    var arr = multiply(2, 1, 2, 3); 
    console.log(arr);  // [2, 4, 6]
    
下例演示了你可以在剩余参数上使用任意的数组方法，而arguments对象不可以：

    function sortRestArgs(...theArgs) {
      var sortedArgs = theArgs.sort();
      return sortedArgs;
    }
     
    alert(sortRestArgs(5,3,7,1)); // 弹出 1,3,5,7
     
    function sortArguments() {
      var sortedArgs = arguments.sort();
      return sortedArgs; // 不会执行到这里
    }
     
    alert(sortArguments(5,3,7,1)); // 抛出TypeError异常:arguments.sort is not a function
    
为了在arguments对象上使用Array方法，它必须首先被转换为一个真正的数组。

    function sortArguments() {
      var args = Array.prototype.slice.call(arguments);
      var sortedArgs = args.sort();
      return sortedArgs;
    }
    console.log(sortArguments(5, 3, 7, 1)); // shows 1, 3, 5, 7
    
#### 2.1.9 arguments对象

参考链接：
[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)

arguments 是一个对应于传递给函数的参数的类数组对象。

arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。例如，如果一个函数传递了三个参数，你可以以如下方式引用他们：

    arguments[0]
    arguments[1]
    arguments[2]
    
参数也可以被设置：

    arguments[1] = 'new value';
    
arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的Array：

    var args = Array.prototype.slice.call(arguments);
    var args = [].slice.call(arguments);
    
    // ES2015
    const args = Array.from(arguments);
    const args = [...arguments];
    
对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 )。如果你关心性能，尝试通过遍历arguments对象来构造一个新的数组。另一种方法是使用被忽视的Array构造函数作为一个函数：

    var args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));

如果调用的参数多于正式声明接受的参数，则可以使用 arguments 对象。这种技术对于可以传递可变数量的参数的函数很有用。使用 arguments.length来确定传递给函数参数的个数，然后使用arguments对象来处理每个参数。要确定函数签名中（输入）参数的数量，请使用Function.length 属性。

typeof参数返回 'object'。

    console.log(typeof arguments);    // 'undefined'
    // arguments 对象只能在函数内使用
    function test(a){
        console.log(a,Object.prototype.toString.call(arguments));
        console.log(arguments[0],arguments[1]);
        console.log(typeof arguments[0]);
    }
    test(1);
    /*
    1 "[object Arguments]"
    1 undefined
    number
    */
    
可以使用索引确定单个参数的类型。

    console.log(typeof arguments[0]); //this will return the typeof individual arguments.
    
您还可以使用Array.from()方法或扩展运算符将参数转换为真实数组：

    var args = Array.from(arguments);
    var args = [...arguments];
    
arguments: 一个包含了传递给当前执行函数参数的类似于数组的对象。
arguments.callee : 当前正在执行的函数。
arguments.caller  : 调用当前执行函数的函数。
arguments.length: 传给函数的参数的数目。
arguments[@@iterator]
返回一个新的Array迭代器对象，该对象包含参数中每个索引的值。

注意:现在在严格模式下，arguments对象已与过往不同。arguments[@@iterator]不再与函数的实际形参之间共享，同时caller属性也被移除。

遍历参数求和

    function add() {
        var sum =0,
            len = arguments.length;
        for(var i=0; i<len; i++){
            sum += arguments[i];
        }
        return sum;
    }
    add()                           // 0
    add(1)                          // 1
    add(1,2,3,4);                   // 10
    
定义连接字符串的函数
这个例子定义了一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下：

    function myConcat(separator) {
      var args = Array.prototype.slice.call(arguments, 1);
      return args.join(separator);
    }
    
    你可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表。
    
    // returns "red, orange, blue"
    myConcat(", ", "red", "orange", "blue");
    
    // returns "elephant; giraffe; lion; cheetah"
    myConcat("; ", "elephant", "giraffe", "lion", "cheetah");
    
    // returns "sage. basil. oregano. pepper. parsley"
    myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley");
    
定义创建HTML列表的方法
这个例子定义了一个函数通过一个字符串来创建HTML列表。这个函数唯一正式声明了的参数是一个字符。当该参数为 "u" 时，创建一个无序列表 (项目列表)；当该参数为 "o" 时，则创建一个有序列表 (编号列表)。该函数定义如下：

    function list(type) {
      var result = "<" + type + "l><li>";
      var args = Array.prototype.slice.call(arguments, 1);
      result += args.join("</li><li>");
      result += "</li></" + type + "l>"; // end list
    
      return result;
    }
    
你可以传递任意数量的参数到该函数，并将每个参数作为一个项添加到指定类型的列表中。例如：

    var listHTML = list("u", "One", "Two", "Three");
    
    /* listHTML is:
    
    "<ul><li>One</li><li>Two</li><li>Three</li></ul>"
    
    */
    
剩余参数、默认参数和解构赋值参数
arguments对象可以与剩余参数、默认参数和解构赋值参数结合使用。

    function foo(...args) {
      return args;
    }
    foo(1, 2, 3);  // [1,2,3]
    
在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变 arguments对象的行为，但是在非严格模式下就有所不同了。

当非严格模式中的函数没有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值会跟踪参数的值（反之亦然）。看下面的代码：

    function func(a) { 
      arguments[0] = 99;   // 更新了arguments[0] 同样更新了a
      console.log(a);
    }
    func(10); // 99
    
并且

    function func(a) { 
      a = 99;              // 更新了a 同样更新了arguments[0] 
      console.log(arguments[0]);
    }
    func(10); // 99
    
当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值不会跟踪参数的值（反之亦然）。相反, arguments反映了调用时提供的参数：

    function func(a = 55) { 
      arguments[0] = 99; // updating arguments[0] does not also update a
      console.log(a);
    }
    func(10); // 10
    
并且

    function func(a = 55) { 
      a = 99; // updating a does not also update arguments[0]
      console.log(arguments[0]);
    }
    func(10); // 10
    
并且

    function func(a = 55) { 
      console.log(arguments[0]);
    }
    func(); // undefined
    
#### 2.1.10 方法函数定义

你可以在支持添加新属性的任何标准的内置对象或用户定义的对象内定义getter(访问方法)和setter(设置方法)。使用对象字面量语法定义getters和setters方法。

##### 2.1.10.1 get

参考链接： 
[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get)

当查找某个对象属性时，该对象属性将会与被调用函数绑定。
get语法将对象属性绑定到查询该属性时将被调用的函数。例如：

    var obj = {
      log: ['a', 'b', 'c'],
      get latest() {
        if (this.log.length == 0) {
          return undefined;
        }
        return this.log[this.log.length - 1];
      }
    }
    
    console.log(obj.latest);
    // expected output: "c"
    
语法：
    {get prop() { ... } }
    {get [expression]() { ... } }

> prop：要绑定到给定函数的属性名。
> expression：从 ECMAScript 2015 开始，还可以使用一个计算属性名的表达式绑定到给定的函数。

有时需要允许访问返回动态计算值的属性，或者你可能需要反映内部变量的状态，而不需要使用显式方法调用。在JavaScript中，可以使用 getter 来实现。虽然可以使用 getter 和 setter 来创建一个伪属性类型，但是不可能同时将一个 getter 绑定到一个属性并且该属性实际上具有一个值。

使用get语法时应注意以下问题：

* 可以使用数值或字符串作为标识；
* 必须不带参数（请参考Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments）；
* 它不能与另一个 get 或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 { get x() { }, get x() { } } 和 { x: ..., get x() { } }）。
* 可通过 delete 操作符删除 getter。

在新对象初始化时定义一个getter
这会为obj创建一个伪属性latest，它会返回log数组的最后一个元素。

    var obj = {
      log: ['example','test'],
      get latest() {
        if (this.log.length == 0) return undefined;
        return this.log[this.log.length - 1];
      }
    }
    console.log(obj.latest); // "test".
    
注意，尝试为latest分配一个值不会改变它。

只需使用 delete，就可删除 getter：

    delete obj.latest;
    
要随时将 getter 添加到现有对象，使用 Object.defineProperty().

    var o = { a:0 }
    
    Object.defineProperty(o, "b", { get: function () { return this.a + 1; } });
    
    console.log(o.b) // Runs the getter, which yields a + 1 (which is 1)
    
使用计算属性名

    var expr = 'foo';
    
    var obj = {
      get [expr]() { return 'bar'; }
    };
    
    console.log(obj.foo); // "bar"
    
Getters 给你一种方法来定义一个对象的属性，但是在访问它们之前不会计算属性的值。 getter 延续计算值的成本，直到需要值，如果不需要，您就不用支付成本。

一种额外的优化技术是用智能或记忆化 getters 延迟属性值的计算并将其缓存以备以后访问。该值是在第一次调用getter 时计算的，然后被缓存，因此后续访问返回缓存值而不重新计算它。这在以下情况下很有用：

* 如果属性值的计算是昂贵的（占用大量RAM或CPU时间，产生工作线程，检索远程文件等）。
* 如果现在不需要该值。它将在稍后使用，或在某些情况下它根本不使用。
* 如果被使用，它将被访问几次，并且不需要重新计算该值将永远不会被改变，或者不应该被重新计算。


这意味着你不应该为你希望更改其值的属性使用懒 getter，因为 getter 不会重新计算该值。

在以下示例中，对象具有一个 getter 属性。在获取属性时，该属性将从对象中删除并重新添加，但此时将隐式显示为数据属性。最后返回得到值。

    get notifier() {
      delete this.notifier;
      return this.notifier = document.getElementById('bookmarked-notification-anchor');
    },
    
对于Firefox代码，另请参阅定义defineLazyGetter()函数的XPCOMUtils.jsm代码模块。

##### 2.1.10.2 set

参考链接：
[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set)

当尝试设置属性时，set语法将对象属性绑定到要调用的函数。例如：

    var language = {
      set current(name) {
        this.log.push(name);
      },
      log: []
    }
    
    language.current = 'EN';
    language.current = 'FA';
    
    console.log(language.log);
    // expected output: Array ["EN", "FA"]

语法

    {set prop(val) { . . . }}
    {set [expression](val) { . . . }}
    
> prop：要绑定到给定函数的属性名。  
> val：用于保存尝试分配给prop的值的变量的一个别名。
> 表达式：从 ECMAScript 2015 开始，还可以使用一个计算属性名的表达式绑定到给定的函数。

在 javascript 中，如果试着改变一个属性的值，那么对应的 setter 将被执行。setter 经常和 getter 连用以创建一个伪属性。不可能在具有真实值的属性上同时拥有一个 setter 器。

使用 set 语法时请注意：

* 它的标识符可以是数字或字符串；
* 它必须有一个明确的参数 （详见 Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments）；
* 在对象字面量中，不能为一个已有真实值的变量使用 set ，也不能为一个属性设置多个 set。

    ( { set x(v) { }, set x(v) { } } 和 { x: ..., set x(v) { } } 是不允许的 )
    
setter 可以用delete操作来移除。

在对象初始化时定义 setter
这将定义一个对象 language 的伪属性current，当分配一个值时，将使用该值更新log：

    var language = {
      set current(name) {
        this.log.push(name);
      },
      log: []
    }
    
    language.current = 'EN';
    console.log(language.log); // ['EN']
    
    language.current = 'FA';
    console.log(language.log); // ['EN', 'FA']
    
请注意，current属性是未定义的，访问它时将会返回 undefined。

我们可以使用delete操作符移除 setter。

    delete o.current;
    
我们可以随时使用 Object.defineProperty() 给一个已经存在的对象添加一个 setter。

    var o = { a:0 };
    
    Object.defineProperty(o, "b", { set: function (x) { this.a = x / 2; } });
    
    o.b = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
    console.log(o.a) // 5
    
使用计算属性名

    var expr = "foo";
    
    var obj = {
      baz: "bar",
      set [expr](v) { this.baz = v; }
    };
    
    console.log(obj.baz); // "bar"
    obj.foo = "baz";      // run the setter
    console.log(obj.baz); // "baz"

#### 2.1.11 方法定义语法

参考链接：
[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions)

从ECMAScript 6开始, 你可以用更短的语法定义自己的方法，类似于getters和setters。

    var obj = {
        foo() {},
        bar() {}
    };
    
从ECMAScript 2015开始，在对象初始器中引入了一种更简短定义方法的语法，这是一种把方法名直接赋给函数的简写方式。

    var obj = {
      foo() {
        return 'bar';
      }
    }
    
    console.log(obj.foo());
    // expected output: "bar"
    
语法：

    var obj = {
      property( parameters… ) {},
      *generator( parameters… ) {},
      async property( parameters… ) {},
      async* generator( parameters… ) {},
    
      // with computed keys:
      [property]( parameters… ) {},
      *[generator]( parameters… ) {},
      async [property]( parameters… ) {},
    
      // compare getter/setter syntax:
      get property() {},
      set property(value) {}
    };

该简写语法与ECMAScript 2015的getter和setter语法类似。

如下代码：

    var obj = {
      foo: function() {
        /* code */
      },
      bar: function() {
        /* code */
      }
    };
    
现可被简写为：

    var obj = {
      foo() {
        /* code */
      },
      bar() {
        /* code */
      }
    };
    
注意：简写语法使用命名函数而不是匿名函数（如…foo: function() {}…）。命名函数可以从函数体调用（这对匿名函数是不可能的，因为没有标识符可以引用）。

生成器方法也可以用这种简写语法定义。使用它们时：

* 简写语法中的星号（* ）必须出现在生成器名前，也就是说* g(){}可以正常工作，而g *(){}不行。
* 非生成器方法定义可能不包含yield关键字。这意味着遗留的生成器函数也不会工作，并且将抛出 SyntaxError。始终使用yield与星号（*）结合使用。

    // 用有属性名的语法定义方法（ES6之前）：
    var obj2 = {
      g: function*() {
        var index = 0;
        while(true)
          yield index++;
      }
    };
    
    // 同一个方法，简写语法：
    var obj2 = { 
      * g() {
        var index = 0;
        while(true)
          yield index++;
      }
    };
    
    var it = obj2.g();
    console.log(it.next().value); // 0
    console.log(it.next().value); // 1

Async 方法也可以使用简写语法来定义。
    
    // 用有属性名的语法定义方法（ES6之前）：
    var obj3 = {
      f: async function () {
        await some_promise;
      }
    };
    
    // 同一个方法，简写语法：
    var obj3 = { 
      async f() {
        await some_promise;
      }
    };
    
生成器方法也能成为 async.

    var obj4 = {
      f: async function* () {
        yield 1;
        yield 2;
        yield 3;
      }
    };
    
    // The same object using shorthand syntax
    var obj4 = {
      async* f() {
       yield 1;
       yield 2;
       yield 3;
      }
    };
    
所有方法定义不是构造函数，如果您尝试实例化它们，将抛出TypeError。

    var obj = { 
      method() {}
    };
    new obj.method; // TypeError: obj.method is not a constructor
    
    var obj = { 
      * g() {} 
    };
    new obj.g; // TypeError: obj.g is not a constructor (changed in ES2016)
    
简单示例

    var obj = {
      a : "foo",
      b(){ return this.a; }
    };
    console.log(obj.b()); // "foo"

速记语法还支持计算的属性名称。

    var bar = {
      foo0: function() { return 0; },
      foo1() { return 1; },
      ['foo' + 2]() { return 2; }
    };
    
    console.log(bar.foo0()); // 0
    console.log(bar.foo1()); // 1
    console.log(bar.foo2()); // 2
    
#### 2.1.12 构造函数 vs 函数声明 vs 函数表达式

对比下面的例子：

    // 一个用Function构造函数定义的函数,被赋值给变量multiply：
    var multiply = new Function('x', 'y', 'return x * y');
    
    // 一个名为multiply的函数声明：
    function multiply(x, y) {
       return x * y;
    } // 没有分号
    
    // 一个匿名函数的函数表达式，被赋值给变量multiply：
     var multiply = function(x, y) {
       return x * y;
     };
     
    // 一个命名为func_named的函数的函数表达式，被赋值给变量multiply：
    var multiply = function func_name(x, y) {
       return x * y;
    };
    
虽然有一些细微的差别，但所起的作用都差不多：

函数名和函数的变量存在着差别。函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名将会导致错误（如果函数之前是通过一个var语句声明的则是undefined）。例如：

    var y = function x() {};
    alert(x); // throws an error
    
当函数是通过 Function's toString method被序列化时，函数名同样也会出现。

另一方面，被函数赋值的变量仅仅受限于它的作用域，该作用域确保包含着该函数被声明时的作用域。

正如第四个例子所展示的那样，函数名与被函数赋值的变量是不相同的. 彼此之间没有关系。函数声明同时也创建了一个和函数名相同的变量。因此，与函数表达式定义不同，以函数声明定义的函数能够在它们被定义的作用域内通过函数名而被访问到：

使用用 'new Function'定义的函数没有函数名。 然而，在 SpiderMonkey JavaScript引擎中，其函数的序列化形式表现的好像它拥有一个名叫"anonymous"的名称一样。比如，使用 alert(new Function()) 输出：

    function anonymous() {
    }
    
而实际上其函数并没有名称，anonymous 不是一个可以在函数内被访问到的变量。例如，下面的例子将会导致错误：

    var foo = new Function("alert(anonymous);"); 
    foo();
    
和通过函数表达式定义或者通过Function构造函数定义的函数不同，函数声明定义的函数可以在它被声明之前使用。举个例子：

    foo(); // alerts FOO!
    function foo() {
       alert('FOO!');
    }
    
函数表达式定义的函数继承了当前的作用域。换言之，函数构成了闭包。另一方面，Function构造函数定义的函数不继承任何全局作用域以外的作用域(那些所有函数都继承的)。

通过函数表达式定义的函数和通过函数声明定义的函数只会被解析一次，而Function构造函数定义的函数却不同。也就是说，每次构造函数被调用，传递给Function构造函数的函数体字符串都要被解析一次 。虽然函数表达式每次都创建了一个闭包，但函数体不会被重复解析，因此函数表达式仍然要快于"new Function(...)"。 所以Function构造函数应尽可能地避免使用。

有一点应该要注意的，在通过解析Function构造函数字符串产生的函数里，内嵌的函数表达式和函数声明不会被重复解析。例如：

    var foo = (new Function("var bar = \'FOO!\';\nreturn(function() {\n\talert(bar);\n});"))();
    foo(); // 函数体字符串"function() {\n\talert(bar);\n}"的这一部分不会被重复解析。
    
函数声明非常容易（经常是意外地）转换为函数表达式。当它不再是一个函数声明：

* 成为表达式的一部分
* 不再是函数或者脚本自身的“源元素” （source element）。“源元素”是脚本或函数体中的非嵌套语句。

    var x = 0;               // source element
    if (x === 0) {           // source element
       x = 10;               // 非source element
       function boo() {}     // 非 source element
    }
    function foo() {         // source element
       var y = 20;           // source element
       function bar() {}     // source element
       while (y === 10) {    // source element
          function blah() {} // 非 source element
          y++;               //非source element
       }
    }
    
例子

    // 函数声明
    function foo() {}
    
    // 函数表达式
    (function bar() {})
    
    // 函数表达式
    x = function hello() {}
    
    if (x) {
       // 函数表达式
       function world() {}
    }
    
    // 函数声明
    function a() {
       // 函数声明
       function b() {}
       if (0) {
          //函数表达式
          function c() {}
       }
    }
    
#### 2.1.14 块级函数

从ECMAScript 6开始，在严格模式下，块里的函数作用域为这个块。ECMAScript 6之前不建议块级函数在严格模式下使用。

    'use strict';
    
    function f() { 
      return 1; 
    }
    
    {  
      function f() { 
        return 2; 
      }
    }
    
    f() === 1; // true
    
    // f() === 2 in non-strict mode
    
非严格模式下的块级函数，一句话：不要用。

在非严格模式下，块中的函数声明表现奇怪。例如：

    if (shouldDefineZero) {
       function zero() {     // DANGER: 兼容性风险
          console.log("This is zero.");
       }
    }
    
ECMAScript 6中，如果shouldDefineZero是false，则永远不会定义zero,因为这个块从不执行。然而，这是标准的新的一部分。这是历史遗留问题，无论这个块是否执行，一些浏览器会定义zero。

在严格模式下，所有支持ECMAScript 6的浏览器以相同的方式处理：只有在shouldDefineZero为true的情况下定义zero，并且作用域只是这个块内。

有条件地定义一个函数的一个更安全的方法是把函数表达式赋给一个变量：

    var zero;
    if (0) {
       zero = function() {
          console.log("This is zero.");
       };
    }
    
下面的函数返回一个字符串，其中包含了一个格式化的、以一个由0开头并填充的数字。

    // 这个函数返回一个由0开头并填充的字符串
    function padZeros(num, totalLen) {
       var numStr = num.toString();             // 用字符串返回值进行初始化
       var numZeros = totalLen - numStr.length; // 计算zeros顺序
       for (var i = 1; i <= numZeros; i++) {
          numStr = "0" + numStr;
       }
       return numStr;
    }
    
下面的语句调用了padZeros函数：

    var result;
    result = padZeros(42,4); // returns "0042"
    result = padZeros(42,2); // returns "42"
    result = padZeros(5,4);  // returns "0005"

你可以通过 typeof 操作符检测一个函数是否存在。在下面的例子中，用一个测试来演示检测window对象是否拥有一个noFunc函数的属性。如果存在，那就使用它；否则就采取其它的一些操作。

    if ('function' === typeof window.noFunc) {
       // use noFunc()
     } else {
       // do something else
     }
     
注意在if语句中，使用了noFunc的引用--在函数名的后面没有括号“（）”，所以实际函数并没有被调用。



