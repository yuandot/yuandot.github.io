---
layout: post
title:  "2019-06-27-Linux 内核设计与实现第3版中文版阅读笔记"
categories: Linux
tag: terminal 
---

* content
{:toc}


## 名词注释
**STL:** Standard Template Library 的简称，标准模板库，是 C++ 的一部分。
## 1 Linux 内核简介
### 1.1 Unix的历史
1977年，贝尔实验室综合各种变体推出了 Unix System III；1983年，AT&T 推出了 System V。  
加州大学伯克利分校推出的变体是 Berkeley Software Distributions(BSD)。伯克利的第一个 Unix 演化版 1977 年推出的 1BSD 系统，实现基于贝尔实验室的 Unix 版本加入了许多修正补丁，还集成了不少额外的软件；1978年推出的 2BSD 系统，其中包括了现在还在使用的 csh，vi 等应用软件；1979年推出的伯克利真正独立开发的 Unix 系统——3BSD 系统，该系统引入了一系列新特性，比如支持虚拟内存；3BSD 系统之后又推出了 4BSD 系列，包括 4.0BSD，4.1BSD，4.2BSD，4.3BSD 等众多分支，这些演化版实现了任务管理，换页机制，TCP/IP 等新特性；1994 年重写了虚拟内存子系统(VM)，并推出了伯克利 Unix 系统的最终官方版——4.4BSD。由于 BSD 的开放性许可，BSD 的开发才得以继续。  

Unix 之所以强大的原因有五点：  

- Unix 很简洁。系统调用少，而且设计目的明确
- Unix 将所有东西都当作文件对待。这种抽象使得很多不同的数据，外设可以通过一套相同的系统接口操作
- Unix的内核和系统工具都是用C语言编写的。可移植性强，开发者更容易接受
- 进程创建快，并且有一个非常独特的 fork() 系统调用。
- 有一套简单稳定的进程间通信元语。  

进程创建快确保Unix的程序把目标放在一次执行保质保量的完成一个任务上，简单稳定的进程间通信保证单一目的的程序方便的组合在一起，解决复杂的任务。正是这种策略和机制分离的设计理念，确保了Unix系统具备清晰的层次化结构。

Unix的成功归功于其简洁和一流的设计。
### 1.2 Linux 简介
1991年，Linus 由于 Minix(教学用的廉价的 Unix，采用 Minix 许可证)，不能轻易修改和发布该系统的源代码，也不能对 Minix 开发者的设计轻举妄动，年底，Linus 发布了 Linux 的早期版本。  
Linux 是类 Unix 系统，但不是 Unix。Linux 借鉴了 Unix 的许多设计，并且实现了 Unix 的 API(由 Posix 标准和其他 Single Unix Specification 定义的)，但是没有直接使用 Unix 的源代码。Linux 没有抛弃 Unix 的设计目标并且保证了 API 的一致。  
Linux 内核是自由(公开)的软件，采用 GNU 的 General Public License(GPL) 第2版作为限制条款。结果是：你可以自由地获取内核代码并随意修改它，但如果你希望发布你修改过的内核，你也得保证让得到你的内核的人同时享有你曾经享受过的所有权利，包括源代码。

### 1.3 操作系统和内核简介
操作系统：整个系统中负责完成最基本功能和系统管理的那些部分(内核，设备驱动程序，启动引导程序，命令行 Shell 和其他种类的用户界面，基本的文件管理工具和系统工具)。  
内核：由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。  
内核一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和被保护起来的内存空间，统称为内核空间。  
应用程序在用户空间执行，只允许使用部分系统资源，并且只能使用某些特定的系统功能，不能直接访问硬件，也不能访问内核分配给别的应用程序的内存范围。  
内核运行：系统以内核态进入内核空间执行  
用户运行：系统以用户态进入用户空间执行  

用户程序通过系统调用与内核进行通信。当一个应用程序执行一条系统调用，我们说内核正在代其执行，进一步解释就是应用程序被称为通过系统调用在内核空间运行，内核被称为运行于进程上下文中。如下图所示：

<center>
<img src="{{'/styles/images/Linux/20190627-the relation of application core hardware.png' | prepend: site.baseurl}}">
</center>

硬件设备想和系统通信，首先发出一个异步中断信号给内核，内核调用相应中断号对应的中断服务程序响应和处理中断。内核可以停止所有中断，也可以有选择地停止某个中断号对应的中断。  
中断服务程序不在进程上下文中执行，它们在一个与所有进程都无关、专门的中断上下文中运行，为了保证终端服务程序能够第一时间响应和处理中断请求，然后快速地退出。  
上下文代表内核活动的范围。  
处理器在任何指定时间点上的活动必然为下列三者之一：  

* 运行于用户空间，执行用户进程  
* 运行于内核空间，处理进程上下文，代表某个特定的进程执行  
* 运行于内核空间，处理中断上下文，与任何进程无关，处理某个特定的中断  

例如，当CPU空闲时，内核就运行一个空进程，处于进程上下文，运行于内核空间。

### 1.4 Linux 内核和 Unix 内核比较
单内核：整体上作为一个单独的大过程，同时运行在一个单独的地址空间上。简单和性能高的特点，大多数 Unix 系统设计为单内核。  
微内核：功能被划分为多个独立的过程，每个过程叫做一个服务器。理想情况下，只有强烈请求特权服务的服务器才运行在特权模式下，其他服务器运行在用户控件。所有服务器独立并运行在各自的地址空间，采用进程间通信(IPC)机制。特点:避免一个服务器的失效祸及所有。  
对比：由于IPC机制开销多于函数调用，另外还有内核空间和用户空间的上下文切换。因此微内核比单内核开销大。所有实际基于微内核的系统都让大部分或全部服务器位于内核，这样就可以直接调用函数，消除频繁的上下文切换，但是这违背了微内核设计的初衷。  
Linux 采用单内核，但是汲取了微内核的精华（模块化设计，抢占式内核，支持内核线程以及动态装载内核模块），并让所有事情都运行在内核态。  
Linux 和 Unix 的区别：

* Linux 支持动态加载内核模块。允许在需要时动态卸载和加载部分内核代码。
* Linux 支持多处理(SMP)机制，传统的 Unix 不支持，许多 Unix 的变体支持 SMP。
* Linux 内核可以抢占。允许在内核运行的任务优先执行的能力。大多数 Unix 内核不支持，Solaris 和 IRIX 支持。
* Linux 独特的线程支持，不区分线程和进程，对于内核所有进程都一样，只不过其中一些共享资源而已。
* Linux 提供具有设备类的面向对象的设备模型，热插拔时间，以及用户空间的设备文件系统。
* Linux 忽略了 Unix 中一些特性和过时标准。
* Linux 体系自由。

### 1.5 Linux 版本
Linux 内核：稳定和开发中。  
命名机制：x.y.z.a
>x：主版本号，y:从版本号(偶数代表稳定版，奇数代表开发版)，z:修订版本号，a:可选的稳定版本号

## 2 从内核出发
### 2.1 获取内核源码
* 从 [内核源码](https://www.kernel.org/) 处可以获取内核源码压缩包或者补丁。  
内核压缩包格式：
    + GNU zip(gzip, .gz)，解压使用命令：`tar xvzf linux-x.y.z.tar.gz`   
    + bzip2(.bz2) 是默认和首选形式，因为在压缩上比 gzip 更有优势，解压使用命令：`tar xvjf linux-x.y.z.tar.bz2`  
    + xz(.xz) 比 bzip2 的压缩率更高，解压使用命令：`tar -Jxf linux-x.y.z.tar.xz`  
* 使用 git 工具，使用指令：`git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git` 来获取，还可以使用 `git pull` 同步远程代码到本地分支。  
  
* 使用补丁，增量补丁可以作为版本转移的桥梁，不需要下载庞大的源码，只需要给旧版本打上一个增量补丁，就是更新内核版本。一般一个给定版本的内核补丁总是打在前一个版本上。命令：`patch -pl < ../patch-x.y.z`  

### 2.2 内核源码树
########## 填充源码树目录

### 2.3 编译内核
#### 2.3.1 配置内核。  
可以配置的选项以 `CONFIG_FEATURE` 形式表示，配置选项可以用来决定哪些文件编译进内核，也可以通过预处理命令处理代码。  
配置选项的值可以是 yes，no，module 或者字符串，整数。module 意味着编译时这部分功能的实现代码以模块(一种可以动态安装的独立代码段)的形式生成。字符串和整数来指定内核源码可以访问的值。  
命令行配置工具：`make config`，要求用户选择选项，比较耗时。  
图形界面工具：`make menuconfig` 或者 `make gconfig`。  
基于默认的配置为你的体系结构创建配置：`make defconfig`，在 /boot/config-3.10.0-514.el7.x86_64 文件中有现有系统的配置。    
已经配置的选项会存放在源码目录中的 .config 文件中，可以直接修改这个文件，在使用修改后的配置文件配置新的代码树时，需要使用 `make oldconfig` 指令来验证和更新配置。   
配置选项 `CONFIG_IKCONFIG_PROC` 把压缩过的内核配置文件放在 /proc/config.gz 文件中，可以通过下面命令来使用这个配置：`zcat /proc/config.gz > .config; make oldconfig`    

#### 2.3.2 编译内核。   
`make > ../detritus`：将编译输出信息放在文件中     
`make > /dev/null`：将编译输出信息丢弃    
`make -j32 > /dev/null`：使用多个 32 个作业编译。由于编译大型源码包括 I/O 等待所花费的时间；每个处理器上一般衍生 1-2 个作业。  
使用 distcc 或者 ccache 工具来动态改善内核编译时间。
可以使用一下命令来统计编译时间，并且编译完成后提示：`date >> /app/date.log ; make -j 8 ;date >> /app/date.log; for i in {1..10};do echo -e "\a";sleep 0.5;done`    
 
#### 2.3.3 安装内核
可以查阅启动引导工具的说明，按照指导将内核映像拷贝到合适的位置，并且按照启动要求安装内核。**要保证随时有一个或两个可以启动的内核。**例如，使用 grub 的 x86 系统，需要将 arch/i386/boot/bzImage 拷贝到 /boot 使用 vmlinuz-version 这样命名，并且编辑 /etc/grub/grub.conf 文件来为内核建立一个新的启动项。   
使用命令：

    make modules_install    # 安装模块，安装完成后，/lib/modules 目录下回出现新的内核
    make install   # 安装内核相关文件，安装之后，/boot 文件夹下会生成相应的 vmlinuz 和 initramfs 文件，
    # 这时候查看 /boot/grub2/grub.cfg 文件就可以看到已经生成了安装的新内核的启动菜单
    
#### 2.3.4 卸载内核
1. 删除/lib/modules/目录下不需要的内核库文件
2. 删除/usr/src/linux/目录下不需要的内核源码
3. 删除/boot目录下启动的内核和内核映像文件
4. 更改grub的配置文件，删除不需要的内核启动列表

### 2.4 内核开发的特点
最重要的差异：

* 内核编程既不能访问 C 库，也不能访问标准 C 头文件
* 内核编程必须使用 GNU C
* 内核编程缺乏像用户空间那样的内存保护机制
* 内核编程难以执行浮点运算
* 内核编程给每个进程只有一个很小的定长堆栈
* 由于内核支持异步中断，抢占和 SMP，因此必须时刻注意同步和并发
* 要考虑可移植性的重要性
#### 2.4.1 无 libc 库和标准头文件
不能使用 libc 库的原因：先有鸡还是先有蛋的悖论，最主要的是速度和大小(对内核来说，哪怕 libc 的一个字节都太多且太低效了)。  
大部分 C 库函数在内核中都已经实现了。   
基本的头文件在 /include 目录下，例如头文件<linux/inotify.h> 对应内核源码树的 include/linux/inotify.h。   
体系结构相关的头文件集位于内核源码树的 arch/<architecture>/include/asm 目录下，例如 X86 下，体系结构相关的头文件就是 arch/x86/include/asm，内核代码使用 <asm/ioctl.h>   
内核使用 printk() 来代替 printf()，printk 可以通过指定一个标志来设置优先级。
#### 2.4.2 GNU C
内核使用 C 语言编写，但并不完全符合 ANSI C 标准，涵盖了 ISO C99 标准和 GNU C 扩展特性。   
扩展特性有：    

* 内联函数：C99 和 GNU C 都支持。函数会在它所调用的位置展开，来消除函数调用和返回带来的开销(寄存器存储和恢复)，另外提供进一步优化代码的可能。代价是代码变长，占用更多的内存或者更多的指令缓存。通常将对时间要求高，且本身长度比较短的函数定义为内联函数。在头文件中定义内联函数，需要使用 `static` 来限定，为了编译时不会为内联函数单独建立一个函数体，例如：`static inline void wolf(void)`。如果仅仅某个源文件使用，可以定义在该文件开始处。为了类型安全和易读，优先使用内联函数，而不是宏。    
* 内联汇编：gcc 支持 C 函数嵌入汇编，知道对应的体系结构的前提下，使用 asm() 指令来嵌入汇编代码。在偏近结构底层或对执行时间要求严格的地方，一般使用汇编语言。   
* 分支声明：likely(success) 用于 sucess 通常不为 0 的情况下；unlikely(success) 用于 success 通常为 0 的情况下。**绝大多数情况下这个条件别弄反了，否则就会导致性能下降，而不是性能提升了。**   

#### 2.4.3 没有内存保护机制
用户程序非法访问内存，内核会发送 SIGSEGV 信号并结束进程。   
内核发生内存错误会导致 oops，但不会告诉你。  
内核中的内存不分页， 用一个字节就少一个字节。   
#### 2.4.4 不要轻易在内核中使用浮点数
用户进程执行浮点操作，内核会完成从整数操作到浮点数操作的模式转换。但是内核并不能完美地支持浮点操作。
#### 2.4.5 容积小而固定的栈
内核栈的准确大小随体系结构而变。从历史来说，内核栈的大小是两页，32bit 的内核栈是 8K，64bit 的内核栈是 16K。
#### 2.4.6 同步和并发
内核很容易产生竞争条件，需要同步机制来保证不出现竞争条件。常用解决竞争的办法是自旋锁和信号量。
#### 2.4.7 可移植性
要保证大部分 C 代码与体系结构无关。把与体系结构有关的代码分离出来。   

## 3 进程管理
### 3.1 进程
* 进程：概况起来就是出于执行期的程序以及相关资源的总称。处于执行时的程序，包含可执行的程序代码，打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间，一个或多个执行线程，还包括存放全局变量的数据段等等，也就是正在执行的程序代码的实时结果。可以多个进程执行同一个程序，也可以多个进程共享文件和地址空间之类的资源。
* 线程：进程中活动的对象，内核调度的对象，拥有独立的程序计数器，进程栈和一组进程寄存器。

传统的 Unix 系统一个进程只包含一个线程，现在的系统一个进程可以包含多个线程，对 Linux 而言，线程是一种特殊的进程。  

### 3.2 进程描述符及任务结构
进程描述符(process descriptor):存放在叫任务队里的双向循环链表中；类型是 `task_struct`，定义在<linux/sched.h>文件中，该描述符包含的数据能完成地描述一个正在执行的程序。  

#### 3.2.1 分配进程描述符
Linux 通过 slab 分配器分配 `task_struct` 结构，来达到对象复用和缓存着色的目的。slab 分配器动态生成 `task_struct` 结构，只需在栈地(向下增长的栈)或栈顶(向上增长的栈)创建一个新的结构 `thread_info` 结构(asm/thread_info.h 文件中定义)，该结构中的 `task` 域存放的就是执行该任务实际 `task_struct` 的指针。  